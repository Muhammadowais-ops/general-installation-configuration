############# these are the jq commands we can use for json file parsing in linux ################
sample data we can play

{
  "employees": [
    {
      "id": 1,
      "name": "Alice",
      "age": 30,
      "department": "HR",
      "skills": ["communication", "management"]
    },
    {
      "id": 2,
      "name": "Bob",
      "age": 25,
      "department": "Engineering",
      "skills": ["programming", "problem-solving"]
    },
    {
      "id": 3,
      "name": "Charlie",
      "age": 35,
      "department": "Engineering",
      "skills": ["design", "leadership"]
    },
    {
      "id": 4,
      "name": "David",
      "age": 28,
      "department": "HR",
      "skills": ["recruitment", "communication"]
    }
  ]
}


### it will print data in pretty json format #####3
cat test.json | jq '.'

##### how to select values in json ########

cat test.json | jq '.employees'

cat test.json | jq '.employees[2]'

cat test.json | jq '.employees[2:4]'

### to select from employees id values ######

cat test.json | jq '.employees[].id'

### to select multiple values ######

cat test.json | jq '.employees[]| {id,name}'

### you can use select as condition to select specific value not in this above command output not return as array

cat test.json | jq '.employees[].id | select (. == 1)'

### incase output return as array you can use map 

cat test.json | jq '.employees[]| {id,name}| map(select (. == 1))'

## select from multiple value
cat test.json | jq '.employees[] | {id, name} | select(.name == "Alice")'

### incase you don't want a string you can use -r to remove it 

cat test.json | jq -r '.employees[].name'

#######  you can use any if output return with true and false
cat test.json | jq '.employees[] | {id, name} | select(.name == "Alice")| any'

### object has the key ######
cat test.json | jq '.employees | map(has("name"))'


###
cat test.json | jq '.employees[].skills | map(select(. == "recruitment"))'
## you can also convert below output to json data format

[root@ip-172-31-71-114 ec2-user]# cat test.json | jq '.employees[].id'
1
2
3
4
[root@ip-172-31-71-114 ec2-user]# cat test.json | jq '[.employees[].id]'
[
  1,
  2,
  3,
  4
]

The -e option does not automatically make the command exit on failure (like exit 1 or similar behavior). It only sets the exit status based on the result of the jq filter. You can capture this exit status in a shell script or check it using $?.

[root@ip-172-31-71-114 ec2-user]# jq -e 'length < 0' test.json 
false
[root@ip-172-31-71-114 ec2-user]# echo $?
1
[root@ip-172-31-71-114 ec2-user]# 



### you can get the required json output and save into another json file #########


cat test.sh 
#!/bin/bash

# Read the skills from the JSON file and store them in a variable
TESTM=$(jq "[.employees[] | {id,name}]" test.json)

# Use --argjson to pass the JSON value into jq
jq -n --argjson skills "$TESTM" '{skills: $skills}' > new.json
